#include "Parser.h"#include <iostream>Parser::Parser(){}void Parser::parse(vector<Polygone*> terminaux){	int prev_nb_noeuds = 0;	int iter = 0;	while(true) //itérations	{		iter = iter+1;		cout<<"------ Itération "<<iter<<" --------"<<endl;		for(vector<Regle*>::iterator it = regles.begin();it!=regles.end();it++)				}	}		void ajouterNoeud(Noeud* n);		vector<Polygone*> terminaux;		void computeAdjacencies();		void ajouterRegle(Regle* r);		//void ajouterRegle(RegleSequence* r);		map<Polygone*, set<Polygone*> > adj;/** La matrice d'adjacence entre polygones*/		vector<Regle*> regles; /** Les règles de la grammaire*/		vector<Noeud*> foret; /** La forêt des non-terminaux reconnus */		map<string,set<Noeud*> > noeudsParType; /** A chaque type, l'ensemble des noeuds correspondants */		void generateDot(string filename, bool axiomeSeulement);		//map<Regle*,set<Noeud*> > seqDejaTraitees; /** Pour chaque règle de séquence, listes à 1 élément déjà construites */		map<Noeud*,set<Noeud*> > exclusivite ; /** Relation d'exclusivité. A chaque noeud est associé la liste des noeuds qui ne peuvent apparaître dans le même arbre. */		//map<string,set<RegleSequence*> >  reglesSequence; /** Associe à chaque non-terminal les règles séquence dans lesquelles il apparait. */ 		void afficherMeilleur();