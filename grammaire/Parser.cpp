#include "Parser.h"#include <iostream>#include "parsing/Terminal.h"#include <fstream>#include <queue>#include <sstream>Parser::Parser(){}void Parser::parse(vector<Polygone*> terminaux){	this->terminaux = terminaux;	int num=1;	for(vector<Polygone*>::iterator it = terminaux.begin();it!=terminaux.end();it++)	{		Terminal* t = new Terminal(*it,num++);		ajouterNoeud(t);	}		int prev_nb_noeuds = 0;	int iter = 0;	int r=0;	while(true) //itérations	{		r=0;		iter = iter+1;		cout<<"------ Itération "<<iter<<" --------"<<endl;		for(vector<Regle*>::iterator it = regles.begin();it!=regles.end();it++)		{			cout<<"Application de la regle "<<(r++)<<endl;			vector<Noeud*> res = (*it)->appliquer(this);			int itt=0;			cout<<"On a récupéré "<<res.size()<<" résultats"<<endl;			for(vector<Noeud*>::iterator it=res.begin();it!=res.end();it++)			{				ajouterNoeud(*it);				//cout<<"Ajout à la foret du noeud"<<(++itt)<<endl;				}					}		ostringstream oss (ostringstream::out);		oss<<"arbre_"<<iter<<".dot";		generateDot(oss.str(),false);		cout<<"Nombre de noeuds : "<<foret.size()<<endl;		for(map<string,set_noeud>::iterator it = noeudsParType.begin();it!=noeudsParType.end();it++)		{		cout<<it->first<<" : "<<it->second.size()<<endl;		/*unsigned nbuckets = it->second.bucket_count();		std::cout << "myset has " << nbuckets << " buckets:\n";		for (unsigned i=0; i<nbuckets; ++i) {    std::cout << "bucket #" << i << " has " << it->second.bucket_size(i) << " elements.\n";  }*/		}		if(foret.size()==prev_nb_noeuds) //si pas de nouveau noeud créé			break;		prev_nb_noeuds = foret.size();	}		//generateDot("arbre.dot",true);	//afficherMeilleur("murs");	//tous("murs");	}void Parser::ajouterNoeud(Noeud* n){	/*On vérifie si le noeud existe pas déjà*/	/* Version bourrin, essayer de faire marcher la unordered_set*/	set_noeud others=noeudsParType[n->getType()];	for(set_noeud::iterator it = others.begin();it!=others.end();it++)		if(n->equals(*it))			return;	/*if(noeudsParType[n->getType()].count(n)>0)		return;*/	//C'est bon, on doit effectivement l'ajouter	/*cout<<"Ajout du noeud "<<n->getType()<<" d'enfants ";	vector<Noeud*> e =n->getEnfants();	cout<<e.size()<<" : ";	for(vector<Noeud*>::iterator it =e.begin();it!=e.end();it++)		cout<<(*it)<<" ("<<(*it)->nom_parser<<") ";	cout<<endl;*/	foret.push_back(n);	noeudsParType[n->getType()].insert(n);	ostringstream oss;	oss<<n->getType()<<noeudsParType[n->getType()].size();	n->nom_parser = oss.str();	//On gère l'exclusivité	exclusivite[n].insert(n);	vector<Noeud*> enfants = n->getEnfants();	for(vector<Noeud*>::iterator it = enfants.begin();it!=enfants.end();it++)	{		exclusivite[n].insert(*it);		exclusivite[*it].insert(n);		set<Noeud*> exclus = exclusivite[*it];		for(set<Noeud*>::iterator it2 = exclus.begin();it2!=exclus.end();it2++)		{			exclusivite[*it2].insert(n);			exclusivite[n].insert(*it2);		}	}}void Parser::computeAdjacencies(){}void Parser::ajouterRegle(Regle* r){	regles.push_back(r);}void Parser::generateDot(string filename, bool axiomeSeulement){	ofstream f;	f.open(filename.c_str());	f<<"digraph G{"<<endl;	set<Noeud*> dejaVus;	queue<Noeud*> aVoir;	for(vector<Noeud*>::iterator it = foret.begin();it!=foret.end();it++)	{		if((axiomeSeulement&&(*it)->getType().compare("escalier")==0)||(!axiomeSeulement))			aVoir.push(*it);	}	while(!aVoir.empty())	{		Noeud* n = aVoir.front();		aVoir.pop();		if(dejaVus.count(n)>0)			continue;		dejaVus.insert(n);		f<<n->nom_parser<<endl;		vector<Noeud*> enfants = n->getEnfants();		for(vector<Noeud*>::iterator it = enfants.begin();it!=enfants.end();it++)		{			f<<n->nom_parser<<"->"<<(*it)->nom_parser<<endl;			aVoir.push(*it);		}	}	f<<"}";	f.close();}void Parser::generateDot(string filename, Noeud* racine){	ofstream f;	f.open(filename.c_str());	f<<"digraph G{"<<endl;	set<Noeud*> dejaVus;	queue<Noeud*> aVoir;	aVoir.push(racine);	while(!aVoir.empty())	{		Noeud* n = aVoir.front();		aVoir.pop();		if(dejaVus.count(n)>0)			continue;		dejaVus.insert(n);		f<<n->nom_parser<<endl;		vector<Noeud*> enfants = n->getEnfants();		for(vector<Noeud*>::iterator it = enfants.begin();it!=enfants.end();it++)		{			f<<n->nom_parser<<"->"<<(*it)->nom_parser<<endl;			aVoir.push(*it);		}	}	f<<"}";	f.close();}void Parser::tous(string axiome){	//cout<<"OK au début de tous"<<endl;	ofstream f;	f.open("tous.txt");	set_noeud candidats = noeudsParType[axiome];	for(set_noeud::iterator it = candidats.begin();it!=candidats.end();it++)	{	queue<Noeud*> aVoir;		aVoir.push(*it);	while(!aVoir.empty())	{		Noeud* n = aVoir.front();		aVoir.pop();		if(n->getType().compare("polygone")==0)			f<<(int)((*n)["number"])<<" ";		vector<Noeud*> enfants = n->getEnfants();		for(vector<Noeud*>::iterator it = enfants.begin();it!=enfants.end();it++)		{			aVoir.push(*it);		}	}		f<<endl;	}	f.close();}void Parser::afficherMeilleur(string axiome){	set_noeud candidats = noeudsParType[axiome];	int best_num=0;	Noeud* best=NULL;	for(set_noeud::iterator it = candidats.begin();it!=candidats.end();it++)	{	int nb_terminaux=0;	queue<Noeud*> aVoir;	aVoir.push(*it);	while(!aVoir.empty())	{		Noeud* n = aVoir.front();		aVoir.pop();		if(n->getType().compare("polygone")==0)			nb_terminaux++;			vector<Noeud*> enfants = n->getEnfants();		for(vector<Noeud*>::iterator it = enfants.begin();it!=enfants.end();it++)		{			aVoir.push(*it);		}	}	if(nb_terminaux>best_num)	{		best_num = nb_terminaux;		best=*it;	}	}	/* Affichage du meilleur arbre*/	ofstream f,f2;	f.open("meilleur.dot");	f2.open("liste_meilleur.txt");	f<<"digraph G{"<<endl;	queue<Noeud*> aVoir;	aVoir.push(best);	while(!aVoir.empty())	{		Noeud* n = aVoir.front();		aVoir.pop();		f<<n->nom_parser<<endl;		vector<Noeud*> enfants = n->getEnfants();		for(vector<Noeud*>::iterator it = enfants.begin();it!=enfants.end();it++)		{		f<<n->nom_parser<<"->"<<(*it)->nom_parser<<endl;				aVoir.push(*it);		}		if(n->getType().compare("polygone")==0)		{			f2<<(int)(n->getAttribut("number"))<<" ";			cout<<n->nom_parser<<" "<<(int)(n->getAttribut("number"))<<endl;		}	}	f<<"}";	f.close();	f2.close();}