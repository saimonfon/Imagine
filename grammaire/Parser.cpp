#include "Parser.h"#include <iostream>#include "parsing/Terminal.h"#include <fstream>#include <queue>#include <sstream>Parser::Parser(){}void Parser::parse(vector<Polygone*> terminaux){	this->terminaux = terminaux;	int num=0;	for(vector<Polygone*>::iterator it = terminaux.begin();it!=terminaux.end();it++)	{		Terminal* t = new Terminal(*it,num++);		ajouterNoeud(t);	}		int prev_nb_noeuds = 0;	int iter = 0;	while(true) //itérations	{		iter = iter+1;		cout<<"------ Itération "<<iter<<" --------"<<endl;		for(vector<Regle*>::iterator it = regles.begin();it!=regles.end();it++)		{			vector<Noeud*> res = (*it)->appliquer(this);			for(vector<Noeud*>::iterator it=res.begin();it!=res.end();it++)				ajouterNoeud(*it);		}		ostringstream oss (ostringstream::out);		oss<<"arbre_"<<iter<<".dot";		generateDot(oss.str(),false);	}	generateDot("arbre.dot",true);	afficherMeilleur();	}void Parser::ajouterNoeud(Noeud* n){	/*On vérifie si le noeud existe pas déjà*/	set<Noeud*> candidats = noeudsParType[n->getType()];	for(set<Noeud*>::iterator it = candidats.begin();it!=candidats.end();it++)	{		if(n->equals(*it))			return;	}	//C'est bon, on doit effectivement l'ajouter	foret.push_back(n);	noeudsParType[n->getType()].insert(n);	//On gère l'exclusivité	exclusivite[n].insert(n);	vector<Noeud*> enfants = n->getEnfants();	for(vector<Noeud*>::iterator it = enfants.begin();it!=enfants.end();it++)	{		exclusivite[n].insert(*it);		exclusivite[*it].insert(n);		set<Noeud*> exclus = exclusivite[*it];		for(set<Noeud*>::iterator it2 = exclus.begin();it2!=exclus.end();it2++)		{			exclusivite[*it2].insert(n);			exclusivite[n].insert(*it2);		}	}}void Parser::computeAdjacencies(){}void Parser::ajouterRegle(Regle* r){	regles.push_back(r);}void Parser::generateDot(string filename, bool axiomeSeulement){	ofstream f;	f.open(filename.c_str());	f<<"digraph G{"<<endl;	set<Noeud*> dejaVus;	queue<Noeud*> aVoir;	for(vector<Noeud*>::iterator it = foret.begin();it!=foret.end();it++)	{		if((axiomeSeulement&&(*it)->getType().compare("escalier")==0)||(!axiomeSeulement))			aVoir.push(*it);	}	while(!aVoir.empty())	{		Noeud* n = aVoir.front();		aVoir.pop();		if(dejaVus.count(n)>0)			continue;		dejaVus.insert(n);		cout<<n->nom_parser<<endl;		vector<Noeud*> enfants = n->getEnfants();		for(vector<Noeud*>::iterator it = enfants.begin();it!=enfants.end();it++)		{			cout<<n->nom_parser<<"->"<<(*it)->nom_parser<<endl;			aVoir.push(*it);		}	}	f<<"}";	f.close();}void Parser::afficherMeilleur(){	set<Noeud*> candidats = noeudsParType["escalier"];	int best_num=0;	Noeud* best=NULL;	for(set<Noeud*>::iterator it = candidats.begin();it!=candidats.end();it++)	{	int nb_terminaux=0;	queue<Noeud*> aVoir;	aVoir.push(*it);	while(!aVoir.empty())	{		Noeud* n = aVoir.front();		aVoir.pop();		if(n->getType().compare("polygone")==0)			nb_terminaux++;			vector<Noeud*> enfants = n->getEnfants();		for(vector<Noeud*>::iterator it = enfants.begin();it!=enfants.end();it++)		{			aVoir.push(*it);		}	}	if(nb_terminaux>best_num)	{		best_num = nb_terminaux;		best=*it;	}	}	/* Affichage du meilleur arbre*/	ofstream f;	f.open("meilleur.dot");	f<<"digraph G{"<<endl;	queue<Noeud*> aVoir;	aVoir.push(best);	while(!aVoir.empty())	{		Noeud* n = aVoir.front();		aVoir.pop();		cout<<n->nom_parser<<endl;		vector<Noeud*> enfants = n->getEnfants();		for(vector<Noeud*>::iterator it = enfants.begin();it!=enfants.end();it++)		{		cout<<n->nom_parser<<"->"<<(*it)->nom_parser<<endl;				aVoir.push(*it);		}	}	f<<"}";	f.close();}