#include "RegleSequence.h"
#include "../parsing/NonTerminal.h"
#include <iostream>
#include <algorithm>
using namespace std;

/** Renvoie les noeuds résultants de l'application de la règle à l'état courant du parser.
	*@param parser Le parser de la grammaire en cours d'exécutino
	*@return Les noeuds créés. */
vector<Noeud*> RegleSequence::appliquer(Parser* p)
{
	/* Ajouter les listes à un élément non encore construites */
	vector<Noeud*> candidats = p->noeudsParType[this->type];
	for(int i = 0;i<candidats.size();i++)
	{
		if(dejaTraites.count(candidats[i])>0)
		continue;
		bool okCondition = true;
		for(vector<ConditionUnique*>::iterator it = conditions.begin();it!=conditions.end();it++)
		if(!((*it)->estVerifiee(candidats[i])))
		{
			okCondition = false;
			break;
		}
		if(!okCondition)
		continue;
		vector<Noeud*> e;
		e.push_back(candidats[i]);
		Element* new_elem = new Element(e,candidats[i]->getAttributs(),candidats[i]->getAttributs());
		elements.insert(new_elem);
		dejaTraites.insert(candidats[i]);
		
		//Ajout à la table de hachage
		for(vector<ConditionAdj*>::iterator it = condSuccAdj.begin();it!=condSuccAdj.end();it++)
		{
			ConditionAdj* cadj = *it;
			//cout<<cadj->att_i<<" "<<cadj->att_j<<endl;
			//cout<<candidats[i]->getAttribut(cadj->att_i)<<" "<<candidats[i]->getAttribut(cadj->att_j)<<endl;
			table_debuts[cadj][(Polygone*)candidats[i]->getAttribut(cadj->att_i)].insert(new_elem);
			table_fins[cadj][(Polygone*)candidats[i]->getAttribut(cadj->att_j)].insert(new_elem);
			//cout<<"Taille de la table de hachage "<<table_fins[cadj].size()<< " itération "<<i<<endl;
		}
		for(vector<ConditionEgal*>::iterator it = condSuccEgal.begin();it!=condSuccEgal.end();it++)
		{
			ConditionEgal* ceg = *it;
			table_eg_debuts[ceg][candidats[i]->getAttribut(ceg->att_i)].insert(new_elem);
			table_eg_fins[ceg][candidats[i]->getAttribut(ceg->att_j)].insert(new_elem);
		}
	}
	cout<<"Ok, listes à un élément crées"<<endl;
	
	
	/* Essayer de coller les listes ensemble */
	bool changement = true;
	//bool changement = false;
	
	/* DANS LA SUITE, EVITER LES COPIES*/
	while(changement)
	{
		changement = false;
		//sort(elements.begin(),elements.end());
		cout<<"Nombre d'éléments "<<elements.size()<<endl;
		for(set<Element*>::iterator it_elem = elements.begin();it_elem!=elements.end();it_elem++)
		{
			set<Element*> succ=elements;
			for(vector<ConditionAdj*>::iterator it = condSuccAdj.begin();it!=condSuccAdj.end();it++)
			{
				ConditionAdj* cadj = *it;
				set<Polygone*> adj = p->adj[(Polygone*) (*it_elem)->att_debut[cadj->att_i]];
				cout<<"Nombre de polygone adjacents "<<adj.size()<<endl;
				set<Element*> adj_elem;
				for(set<Polygone*>::iterator it2 = adj.begin();it2!=adj.end();it2++)
				adj_elem.insert(table_fins[cadj][*it2].begin(),table_fins[cadj][*it2].end());
				cout<<"Nombre de sous listes adjacentes "<<adj_elem.size()<<endl;
				cout<<"Taille de la table de hachage "<<table_fins[cadj].size()<<endl;
				//sort(adj_elem.begin(),adj_elem.end());
				set<Element*> new_set;
				set_intersection(succ.begin(),succ.end(),adj_elem.begin(),adj_elem.end(),std::inserter(new_set, new_set.begin()));
				succ = new_set;
			}
			for(vector<ConditionEgal*>::iterator it = condSuccEgal.begin();it!=condSuccEgal.end();it++)
			{
				ConditionEgal* ceg = *it;
				set<Element*> eg_elem=table_eg_fins[ceg][(*it_elem)->att_debut[ceg->att_i]];
				set<Element*> new_set;
				set_intersection(succ.begin(),succ.end(),eg_elem.begin(),eg_elem.end(),std::inserter(new_set, new_set.begin()));
				succ = new_set;
			}
			cout<<"Nombre de successeurs potentiels "<<succ.size()<<endl;
			for(set<Element*>::iterator it = succ.begin();it!=succ.end();it++)
			{
				//Rajouter l'exclusivité
				if((*it)==(*it_elem))
				continue;
				
				//Vérifier ici les contraintes non solubles analytiquement
				
				changement = true;
				vector<Noeud*> new_membres = (*it_elem)->membres;
				new_membres.insert( new_membres.end(), (*it)->membres.begin(), (*it)->membres.end() );
				//cout<<"Insertion d'un nouvel élément"<<endl;
				Element* new_elem = new Element(new_membres, (*it)->att_debut, (*it_elem)->att_fin);
				elements.insert(new_elem);
				elements.erase(*it_elem);
				elements.erase(*it);
				
				/*Ajout du nouvel élément dans la table de hachage*/
				/* Il fautdrait également supprimer les anciens de la table de hachage*/
				for(vector<ConditionAdj*>::iterator it_cond = condSuccAdj.begin();it_cond!=condSuccAdj.end();it_cond++)
				{
					std::cout<<(*it_cond)->att_i<<" "<<new_elem->att_debut[(*it_cond)->att_i]<<endl;
					std::cout<<(*it_cond)->att_j<<" "<<new_elem->att_fin[(*it_cond)->att_j]<<endl;
					table_debuts[(*it_cond)][(Polygone*) new_elem->att_debut[(*it_cond)->att_i]].insert(new_elem);
					table_fins[(*it_cond)][(Polygone*) new_elem->att_fin[(*it_cond)->att_j]].insert(new_elem);
				}
				for(vector<ConditionEgal*>::iterator it_cond = condSuccEgal.begin();it_cond!=condSuccEgal.end();it_cond++)
				{
					ConditionEgal* ceg = *it_cond;
					table_eg_debuts[ceg][new_elem->att_debut[(*it_cond)->att_i]].insert(new_elem);
					table_eg_fins[ceg][new_elem->att_fin[(*it_cond)->att_j]].insert(new_elem);
				}
				
				goto next;
			}
		}
		next : ;
	}
	vector<Noeud*> res;
	for(set<Element*>::iterator it = elements.begin();it!=elements.end();it++)
	{
		NonTerminal* new_node = new NonTerminal(nom,(*it)->membres);
		res.push_back(new_node);
	}
	return res;
}

/** Crée une règle de type séquence.
	*@param nom Le nom du non-terminal.
	*@param type Le type répété (i.e. apparaissant en partie droite de la règle).*/
RegleSequence::RegleSequence(string nom, string type)
{
	this->nom = nom;
	this->type = type;
}

/** Initialise la règle pour le parsing (doit être appelé avant chaque nouveau parsing). Réinitialise les structures utilisées lors du parsing.*/
void RegleSequence::init()
{}

Element::Element(vector<Noeud*> membres, map<string,void*> att_debut, map<string,void*> att_fin)
{
	this->membres = membres;
	this->att_debut = att_debut;
	this->att_fin  =att_fin;
}